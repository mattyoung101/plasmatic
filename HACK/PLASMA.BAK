// Plasmatic by Matt Young
// UQCS Hackathon 2025
// Programmed on FreeDOS
#include <stdio.h>
#include <graph.h>
#include <conio.h>
#include <math.h>

// brought to you by Howie
// close enough(TM)
#define PI 3.1415926

#define X_RES 320
#define Y_RES 200

// source: libgdx
static inline float
map(float inRStart, float inREnd, float outRStart,
	float outREnd, float value) {
	return outRStart + (value - inRStart) * (outREnd - outRStart)
		/ (inREnd - inRStart);
}

int main(void) {
    int y;
	int x;
	int time = 0;
	int kb_c;

	float scale_x = 1.0;
	float scale_y = 1.0;

	float c_x, c_y, v;

	short c1, c2, c3, v1, v2;

   	 // 320x200; 256 colour mode
    	_setvideomode(_MRES256COLOR);

	srand(0);
	while (1) {
		if (kbhit()) {
			kb_c = getch();
			// 27 == ESC
			if (kb_c == 27)
				break;
	    	}

	    	for (y = 0; y < Y_RES; y++) {
				for (x = 0; x < X_RES; x++) {
/*
					c_x = x * scale_x - scale_x/2.0;
					c_y = y * scale_y - scale_y/2.0;
					v = 0.0;

					v += sin((c_x + time));
					v += sin((c_y + time)/2.0);
					v += sin((c_x + c_y + time)/2.0);

					c_x += scale_x/2.0 * sin(time/2.0);
					c_y += scale_y/2.0 * cos(time/2.0);

					v += sin(sqrt(c_x*c_x + c_y*c_y + 1.0) + time);
					v /= 2.0;
*/
					v1 = sin(time * 3);
					v2 = sin(64 + time * 5);
					c3 = sin(y*3 + time*3);
					c1 = sin(x*3 + time*2);
					c2 = sin((x*v1)/X_RES + (y*v2)/Y_RES + time);

					v = (c1+c2+c3)/3;
					//_setcolor(v * 255);
					//_setpixel(x ,y);
					printf("%d\n", v);
				}
	    	}
	    	time++;
	}

	// return to con mode
	_setvideomode(_DEFAULTMODE);

	printf("Demo done\n");
        return 0;
}
